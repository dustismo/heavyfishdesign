package parser

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"io"
	"io/ioutil"
	"regexp"
	"strings"

	"github.com/dustismo/heavyfishdesign/dom"
	"github.com/dustismo/heavyfishdesign/dynmap"
	"github.com/dustismo/heavyfishdesign/transforms"
	"github.com/dustismo/heavyfishdesign/util"

	"github.com/dustismo/heavyfishdesign/path"
)

type SVGParser struct {
}

type SVGNormalizer struct {
	SegmentOperators path.SegmentOperators
}

// parses the svg, and normalizes it and returns a new svg
func (sn SVGNormalizer) SVGNormalize(xml string, logger *util.HfdLog) (string, error) {
	//scale to 2 inches :shrug:
	width := 2.0
	parser := SVGParser{}
	p, err := parser.ParseSVG(xml, logger)
	if err != nil {
		return "", err
	}
	// now take the path, normalize it,
	// and convert it to viewable svg
	p, err = path.MultiTransform(p,
		transforms.CleanupTransform{Precision: 6},
		transforms.DedupSegmentsTransform{Precision: 6},
		transforms.TrimWhitespaceTransform{SegmentOperators: sn.SegmentOperators},
		transforms.ScaleTransform{
			SegmentOperators: sn.SegmentOperators,
			Width:            width},
	)
	if err != nil {
		return "", err
	}

	// now measure so we have a nice bounding box
	_, br, err := path.BoundingBoxWithWhitespace(p, sn.SegmentOperators)
	if err != nil {
		return "", err
	}
	padding := .1
	stroke := 0.012
	height := br.Y

	pathStr := path.SvgString(p, 3)
	svg := fmt.Sprintf(`<?xml version="1.0"?>
	<!-- Generated by github.com/dustismo/heavyfishdesign -->
	<svg viewBox="%.3f %.3f %.3f %.3f"
		xmlns="http://www.w3.org/2000/svg"
		xmlns:xlink="http://www.w3.org/1999/xlink">
		<path d="%s" style="fill:none;stroke:black;stroke-width:%3f"></path>
	</svg>
	`,
		-padding, -padding,
		width+(2*padding), height+(2*padding),
		pathStr,
		stroke,
	)
	return svg, nil
}

// parses an SVG file for any Path Elements and joining them together
func (s SVGParser) ParseSVG(xml string, logger *util.HfdLog) (path.Path, error) {
	element, err := Parse(strings.NewReader(xml), true)
	p, err := ElementToPath(element, util.NewLog())
	if err != nil {
		return p, err
	}
	return p, nil
}

// Most of the parsing code below was originally from:
// https://github.com/JoshVarga/svgparser

// Element is a representation of an SVG element.
type Element struct {
	Name       string
	Attributes *dynmap.DynMap // map[string]string
	Children   []*Element
	Content    string
}

// convert this element to a path
func ElementToPath(elem *Element, log *util.HfdLog) (path.Path, error) {
	pth, err := elementToPathNoTransforms(elem, log)
	if err != nil {
		return pth, err
	}

	// process any transforms
	transformsStr := elem.Attributes.MustString("transform", "")
	if len(transformsStr) == 0 {
		return pth, nil
	}

	// now pull out the actual transforms, in the form
	// transform1(p1,p2) transform2(p1,p2)
	ts := strings.Split(transformsStr, ") ")
	re := regexp.MustCompile(`([a-z]+)\s*\(([0-9,\s]+)$`)

	for _, t := range ts {
		matches := re.FindAllStringSubmatch("t", -1)
		if matches == nil || len(matches) != 1 || len(matches[0]) != 3 {
			continue
		}

		transformName := matches[0][1]
		println(transformName)

		inputs := []float64{}

		for _, arg := range strings.Split(matches[0][2], ",") {
			v, err := dynmap.ToFloat64(arg)
			if err != nil {
				log.Errorf("error parsing transform %s) argument %s was not a number, skipping", t, arg)
				return pth, err
			}
			inputs = append(inputs, v)
		}

		// now we have the inputs and the transform name
		switch transformName {
		case "matrix":
			if len(inputs) < 6 {
				return pth, fmt.Errorf("matrix transform should have 6 argument %s)", t)
			}
			return transforms.MatrixTransform{
				SegmentOperators: dom.AppContext().SegmentOperators(),
				A:                inputs[0],
				B:                inputs[1],
				C:                inputs[2],
				D:                inputs[3],
				E:                inputs[4],
				F:                inputs[5],
			}.PathTransform(pth)
		case "scale":
			if len(inputs) < 1 {
				return pth, fmt.Errorf("scale transform should have 1 or 2 argument %s)", t)
			}
			return pth, nil
		case "rotate":
			// degrees
			if len(inputs) != 1 {
				return pth, fmt.Errorf("rotate transform should have 1 argument %s)", t)
			}
			return pth, nil
		case "scewX":
			// degrees
			if len(inputs) != 1 {
				return pth, fmt.Errorf("scewX transform should have 1 argument %s)", t)
			}
			return pth, nil
		case "scewY":
			// degrees
			if len(inputs) != 1 {
				return pth, fmt.Errorf("scewX transform should have 1 argument %s)", t)
			}
			return pth, nil
		}

		println(t)
	}
	return pth, nil
}

func elementToPathNoTransforms(elem *Element, log *util.HfdLog) (path.Path, error) {
	// see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Basic_Shapes
	switch elem.Name {
	case "path":
		// <path d="M1927.2,1663.2C1927.2Z" style="fill:none;stroke:black;stroke-width:1.33px;"/>
		return path.ParsePathFromSvg(elem.Attributes.MustString("d", ""))
	case "circle":
		// <circle id="screw_hole" cx="88.8" cy="88.8" r="12" style="fill:none;stroke:black;stroke-width:1.33px;"/>
		draw := path.NewDraw()
		cx, ok := elem.Attributes.GetFloat64("cx")
		if !ok {
			return nil, fmt.Errorf("Circle must have 'cx' property")
		}

		cy, ok := elem.Attributes.GetFloat64("cy")
		if !ok {
			return nil, fmt.Errorf("Circle must have 'cy' property")
		}
		r, ok := elem.Attributes.GetFloat64("r")
		if !ok {
			return nil, fmt.Errorf("Circle must have 'r' property")
		}
		draw.MoveTo(path.NewPoint(
			cx-r,
			cy-r,
		))
		draw.Circle(r)
		return draw.Path(), nil
	case "rect":
		// <rect id="base_outer" x="60" y="60" width="1896" height="1896" style="fill:none;stroke:black;stroke-width:1.33px;"/>
		draw := path.NewDraw()
		x, ok := elem.Attributes.GetFloat64("x")
		if !ok {
			return nil, fmt.Errorf("Rect must have 'x' property")
		}

		y, ok := elem.Attributes.GetFloat64("y")
		if !ok {
			return nil, fmt.Errorf("Rect must have 'y' property")
		}
		w, ok := elem.Attributes.GetFloat64("width")
		if !ok {
			return nil, fmt.Errorf("Rect must have 'width' property")
		}
		h, ok := elem.Attributes.GetFloat64("height")
		if !ok {
			return nil, fmt.Errorf("Rect must have 'height' property")
		}
		draw.MoveTo(path.NewPoint(
			x,
			y,
		))
		draw.Rect(w, h)
		return draw.Path(), nil

	case "elipse":
		// <ellipse cx="75" cy="75" rx="20" ry="5" stroke="red" fill="transparent" stroke-width="5"/>
		return nil, fmt.Errorf("error, 'elipse' is not supported in svg parsing. yet...")
	case "polyline":
		// <polyline points="60 110 65 120 70 115 75 130 80 125 85 140 90 135 95 150 100 145" stroke="orange" fill="transparent" stroke-width="5"/>
		return nil, fmt.Errorf("error, 'polyline' is not supported in svg parsing. yet...")

	case "line":
		// <line x1="10" x2="50" y1="110" y2="150"/>
		draw := path.NewDraw()
		x1, ok := elem.Attributes.GetFloat64("x1")
		if !ok {
			return nil, fmt.Errorf("Line must have 'x1' property")
		}

		y1, ok := elem.Attributes.GetFloat64("y1")
		if !ok {
			return nil, fmt.Errorf("Line must have 'y1' property")
		}
		x2, ok := elem.Attributes.GetFloat64("x2")
		if !ok {
			return nil, fmt.Errorf("Line must have 'x2' property")
		}

		y2, ok := elem.Attributes.GetFloat64("y2")
		if !ok {
			return nil, fmt.Errorf("Line must have 'y2' property")
		}
		draw.MoveTo(path.NewPoint(
			x1,
			y1,
		))
		draw.LineTo(path.NewPoint(x2, y2))
		return draw.Path(), nil
	case "polygon":
		// <polygon points="50, 160 55, 180 70, 180 60, 190 65, 205 50, 195 35, 205 40, 190 30, 180 45, 180"/>
		return nil, fmt.Errorf("error, 'polygon' is not supported in svg parsing. yet...")

	default:
		// process the children
		paths := []path.Path{}
		for _, c := range elem.Children {
			p, err := ElementToPath(c, log)
			if err != nil {
				return p, err
			}
			paths = append(paths, p)
		}
		// join the paths..
		return transforms.SimpleJoin{}.JoinPaths(paths...), nil
	}
}

// NewElement creates element from decoder token.
func NewElement(token xml.StartElement) *Element {
	element := &Element{}
	attributes := dynmap.New()
	for _, attr := range token.Attr {
		attributes.Put(attr.Name.Local, attr.Value)
	}
	element.Name = token.Name.Local
	element.Attributes = attributes
	return element
}

// Compare compares two elements.
func (e *Element) Compare(o *Element) bool {
	if e.Name != o.Name || e.Content != o.Content ||
		e.Attributes.Length() != o.Attributes.Length() ||
		len(e.Children) != len(o.Children) {
		return false
	}

	for _, k := range e.Attributes.Keys() {
		v, _ := e.Attributes.Get(k)
		v1, _ := o.Attributes.Get(k)
		if v != v1 {
			return false
		}
	}

	for i, child := range e.Children {
		if !child.Compare(o.Children[i]) {
			return false
		}
	}
	return true
}

// DecodeFirst creates the first element from the decoder.
func DecodeFirst(decoder *xml.Decoder) (*Element, error) {
	for {
		token, err := decoder.Token()
		if token == nil && err == io.EOF {
			break
		}

		if err != nil {
			return nil, err
		}

		switch element := token.(type) {
		case xml.StartElement:
			return NewElement(element), nil
		}
	}
	return &Element{}, nil
}

// Decode decodes the child elements of element.
func (e *Element) Decode(decoder *xml.Decoder) error {
	for {
		token, err := decoder.Token()
		if token == nil && err == io.EOF {
			break
		}

		if err != nil {
			return err
		}

		switch element := token.(type) {
		case xml.StartElement:
			nextElement := NewElement(element)
			err := nextElement.Decode(decoder)
			if err != nil {
				return err
			}

			e.Children = append(e.Children, nextElement)

		case xml.CharData:
			data := strings.TrimSpace(string(element))
			if data != "" {
				e.Content = string(element)
			}

		case xml.EndElement:
			if element.Name.Local == e.Name {
				return nil
			}
		}
	}
	return nil
}

// Parse creates an Element instance from an SVG input.
func Parse(source io.Reader, validate bool) (*Element, error) {
	raw, err := ioutil.ReadAll(source)
	if err != nil {
		return nil, err
	}
	decoder := xml.NewDecoder(bytes.NewReader(raw))
	// decoder.CharsetReader = charset.NewReaderLabel
	element, err := DecodeFirst(decoder)
	if err != nil {
		return nil, err
	}
	if err := element.Decode(decoder); err != nil && err != io.EOF {
		return nil, err
	}
	return element, nil
}
